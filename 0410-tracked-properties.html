<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0410-tracked-properties - </title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0001-transform-attribute-meta-parameter.html">0001-transform-attribute-meta-parameter</a></li><li><a href="0003-block-params.html">0003-block-params</a></li><li><a href="0003-cli-ember-doctor.html">0003-cli-ember-doctor</a></li><li><a href="0010-engines.html">0010-engines</a></li><li><a href="0011-improved-cp-syntax.html">0011-improved-cp-syntax</a></li><li><a href="0012-help-json-output.html">0012-help-json-output</a></li><li><a href="0015-the-road-to-ember-2-0.html">0015-the-road-to-ember-2-0</a></li><li><a href="0020-sri-default.html">0020-sri-default</a></li><li><a href="0023-command-line-completion.html">0023-command-line-completion</a></li><li><a href="0024-bound-attributes.html">0024-bound-attributes</a></li><li><a href="0028-app-import-output-file.html">0028-app-import-output-file</a></li><li><a href="0029-addon-black-and-whitelist-for-apps.html">0029-addon-black-and-whitelist-for-apps</a></li><li><a href="0045-internet-explorer.html">0045-internet-explorer</a></li><li><a href="0046-cli-improved-release-process.html">0046-cli-improved-release-process</a></li><li><a href="0046-registry-reform.html">0046-registry-reform</a></li><li><a href="0050-cli-production-code-stripping.html">0050-cli-production-code-stripping</a></li><li><a href="0050-improved-actions.html">0050-improved-actions</a></li><li><a href="0053-helpers.html">0053-helpers</a></li><li><a href="0055-anonymous-amd.html">0055-anonymous-amd</a></li><li><a href="0056-improved-release-cycle.html">0056-improved-release-cycle</a></li><li><a href="0057-ember-data-reference-unification.html">0057-ember-data-reference-unification</a></li><li><a href="0058-helper-listing.html">0058-helper-listing</a></li><li><a href="0061-ember-data-background-fetch.html">0061-ember-data-background-fetch</a></li><li><a href="0064-contextual-component-lookup.html">0064-contextual-component-lookup</a></li><li><a href="0065-deprecation-warning-handlers.html">0065-deprecation-warning-handlers</a></li><li><a href="0080-serve-file-api.html">0080-serve-file-api</a></li><li><a href="0086-firefox-in-ci.html">0086-firefox-in-ci</a></li><li><a href="0090-addon-tree-caching.html">0090-addon-tree-caching</a></li><li><a href="0091-cli-addon-instrumentation-experimental-hooks.html">0091-cli-addon-instrumentation-experimental-hooks</a></li><li><a href="0091-weakmap.html">0091-weakmap</a></li><li><a href="0092-blueprint-remove-old-files.html">0092-blueprint-remove-old-files</a></li><li><a href="0095-cli-standardise-targets.html">0095-cli-standardise-targets</a></li><li><a href="0095-router-service.html">0095-router-service</a></li><li><a href="0096-enable-yarn-usage.html">0096-enable-yarn-usage</a></li><li><a href="0101-ember-data-friendly-errors.html">0101-ember-data-friendly-errors</a></li><li><a href="0105-addons-optionalDependencies.html">0105-addons-optionalDependencies</a></li><li><a href="0108-add-custom-transform.html">0108-add-custom-transform</a></li><li><a href="0110-packaging.html">0110-packaging</a></li><li><a href="0114-add-template-lint-addon.html">0114-add-template-lint-addon</a></li><li><a href="0116-qunit-dom.html">0116-qunit-dom</a></li><li><a href="0120-cli-guides.html">0120-cli-guides</a></li><li><a href="0120-route-serializers.html">0120-route-serializers</a></li><li><a href="0121-remove-ember-cli-eslint.html">0121-remove-ember-cli-eslint</a></li><li><a href="0136-contains-to-includes.html">0136-contains-to-includes</a></li><li><a href="0139-isHtmlSafe.html">0139-isHtmlSafe</a></li><li><a href="0143-module-unification.html">0143-module-unification</a></li><li><a href="0150-factory-for.html">0150-factory-for</a></li><li><a href="0176-javascript-module-api.html">0176-javascript-module-api</a></li><li><a href="0178-deprecate-ember-k.html">0178-deprecate-ember-k</a></li><li><a href="0181-deprecate-ember-data-initializers.html">0181-deprecate-ember-data-initializers</a></li><li><a href="0186-track-unique-history-location-state.html">0186-track-unique-history-location-state</a></li><li><a href="0191-deprecate-component-lifecycle-hook-args.html">0191-deprecate-component-lifecycle-hook-args</a></li><li><a href="0194-deprecate-custom-event-manager.html">0194-deprecate-custom-event-manager</a></li><li><a href="0213-custom-components.html">0213-custom-components</a></li><li><a href="0225-ember-engines-mount-params.html">0225-ember-engines-mount-params</a></li><li><a href="0226-named-blocks.html">0226-named-blocks</a></li><li><a href="0229-deprecate-testing-restricted-resolver.html">0229-deprecate-testing-restricted-resolver</a></li><li><a href="0232-simplify-qunit-testing-api.html">0232-simplify-qunit-testing-api</a></li><li><a href="0236-deprecation-ember-string.html">0236-deprecation-ember-string</a></li><li><a href="0237-deprecation-ember-map.html">0237-deprecation-ember-map</a></li><li><a href="0240-es-classes.html">0240-es-classes</a></li><li><a href="0252-browser-support-changes.html">0252-browser-support-changes</a></li><li><a href="0268-acceptance-testing-refactor.html">0268-acceptance-testing-refactor</a></li><li><a href="0272-deprecation-native-function-prototype-extensions.html">0272-deprecation-native-function-prototype-extensions</a></li><li><a href="0276-named-args.html">0276-named-args</a></li><li><a href="0278-template-only-components.html">0278-template-only-components</a></li><li><a href="0280-remove-application-wrapper.html">0280-remove-application-wrapper</a></li><li><a href="0281-es5-getters.html">0281-es5-getters</a></li><li><a href="0286-block-let-template-helper.html">0286-block-let-template-helper</a></li><li><a href="0287-promote-in-element-to-public-api.html">0287-promote-in-element-to-public-api</a></li><li><a href="0293-record-data.html">0293-record-data</a></li><li><a href="0294-optional-jquery.html">0294-optional-jquery</a></li><li><a href="0297-deprecate-ember-logger.html">0297-deprecate-ember-logger</a></li><li><a href="0300-rfc-process-update.html">0300-rfc-process-update</a></li><li><a href="0308-deprecate-property-lookup-fallback.html">0308-deprecate-property-lookup-fallback</a></li><li><a href="0311-angle-bracket-invocation.html">0311-angle-bracket-invocation</a></li><li><a href="0318-array-helper.html">0318-array-helper</a></li><li><a href="0322-deprecate-copy-copyable.html">0322-deprecate-copy-copyable</a></li><li><a href="0324-deprecate-component-isvisible.html">0324-deprecate-component-isvisible</a></li><li><a href="0326-ember-data-filter-deprecation.html">0326-ember-data-filter-deprecation</a></li><li><a href="0329-deprecated-ember-evented-in-ember-data.html">0329-deprecated-ember-evented-in-ember-data</a></li><li><a href="0331-deprecate-globals-resolver.html">0331-deprecate-globals-resolver</a></li><li><a href="0332-ember-data-record-links-and-meta.html">0332-ember-data-record-links-and-meta</a></li><li><a href="0335-deprecate-send-action.html">0335-deprecate-send-action</a></li><li><a href="0337-native-class-constructor-update.html">0337-native-class-constructor-update</a></li><li><a href="0340-deprecate-ember-merge.html">0340-deprecate-ember-merge</a></li><li><a href="0345-discord.html">0345-discord</a></li><li><a href="0364-roadmap-2018.html">0364-roadmap-2018</a></li><li><a href="0369-deprecate-computed-clobberability.html">0369-deprecate-computed-clobberability</a></li><li><a href="0370-deprecate-computed-volatile.html">0370-deprecate-computed-volatile</a></li><li><a href="0372-ember-data-model-factory-for.html">0372-ember-data-model-factory-for</a></li><li><a href="0373-Element-Modifier-Managers.html">0373-Element-Modifier-Managers</a></li><li><a href="0375-deprecate-computed-property-modifier.html">0375-deprecate-computed-property-modifier</a></li><li><a href="0386-remove-jquery.html">0386-remove-jquery</a></li><li><a href="0389-dynamic-tag-names.html">0389-dynamic-tag-names</a></li><li><a href="0391-router-helpers.html">0391-router-helpers</a></li><li><a href="0392-deprecate-component-manager-string-lookup.html">0392-deprecate-component-manager-string-lookup</a></li><li><a href="0395-ember-data-packages.html">0395-ember-data-packages</a></li><li><a href="0398-RouteInfo-Metadata.html">0398-RouteInfo-Metadata</a></li><li><a href="0403-ember-data-identifiers.html">0403-ember-data-identifiers</a></li><li><a href="0408-decorators.html">0408-decorators</a></li><li><a href="0410-tracked-properties.html" class="active">0410-tracked-properties</a></li><li><a href="0415-render-element-modifiers.html">0415-render-element-modifiers</a></li><li><a href="0416-glimmer-components.html">0416-glimmer-components</a></li><li><a href="0418-deprecate-route-render-methods.html">0418-deprecate-route-render-methods</a></li><li><a href="0421-deprecate-application-controller-props.html">0421-deprecate-application-controller-props</a></li><li><a href="0425-website-redesign.html">0425-website-redesign</a></li><li><a href="0431-guides-restructure.html">0431-guides-restructure</a></li><li><a href="0432-contextual-helpers.html">0432-contextual-helpers</a></li><li><a href="0435-modifier-splattributes.html">0435-modifier-splattributes</a></li><li><a href="0440-decorator-support.html">0440-decorator-support</a></li><li><a href="0445-deprecate-with.html">0445-deprecate-with</a></li><li><a href="0446-contribution-guides.html">0446-contribution-guides</a></li><li><a href="0449-deprecate-partials.html">0449-deprecate-partials</a></li><li><a href="0451-injection-parameter-normalization.html">0451-injection-parameter-normalization</a></li><li><a href="0452-ember-data-medium-term-plan.html">0452-ember-data-medium-term-plan</a></li><li><a href="0457-nested-lookups.html">0457-nested-lookups</a></li><li><a href="0459-angle-bracket-built-in-components.html">0459-angle-bracket-built-in-components</a></li><li><a href="0460-yieldable-named-blocks.html">0460-yieldable-named-blocks</a></li><li><a href="0461-ember-data-singleton-record-data.html">0461-ember-data-singleton-record-data</a></li><li><a href="0463-record-data-state.html">0463-record-data-state</a></li><li><a href="0465-record-data-errors.html">0465-record-data-errors</a></li><li><a href="0466-request-state-service.html">0466-request-state-service</a></li><li><a href="0468-classic-decorator.html">0468-classic-decorator</a></li><li><a href="0470-fn-helper.html">0470-fn-helper</a></li><li><a href="0471-on-modifier.html">0471-on-modifier</a></li><li><a href="0478-tracked-properties-updates.html">0478-tracked-properties-updates</a></li><li><a href="0481-component-templates-co-location.html">0481-component-templates-co-location</a></li><li><a href="0486-deprecate-mouseenter.html">0486-deprecate-mouseenter</a></li><li><a href="0487-custom-model-classes.html">0487-custom-model-classes</a></li><li><a href="0491-deprecate-disconnect-outlet.html">0491-deprecate-disconnect-outlet</a></li><li><a href="0494-async-observers.html">0494-async-observers</a></li><li><a href="0521-find-by-identifier.html">0521-find-by-identifier</a></li><li><a href="0522-default-serializers-and-adapters.html">0522-default-serializers-and-adapters</a></li><li><a href="0523-model-argument-for-route-templates.html">0523-model-argument-for-route-templates</a></li><li><a href="0554-deprecate-getwithdefault.html">0554-deprecate-getwithdefault</a></li><li><a href="0558-edition-detection.html">0558-edition-detection</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2018-12-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/410</li>
<li>Relevant Team(s): Ember.js</li>
<li>Authors: Tom Dale, Chris Garrett, Chad Hietala, Yehuda Katz</li>
<li>Tracking: https://github.com/emberjs/rfc-tracking/issues/4</li>
</ul>
<h1><a class="header" href="#tracked-properties" id="tracked-properties">Tracked Properties</a></h1>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Tracked properties introduce a simpler and more ergonomic system for tracking
state change in Ember applications. By taking advantage of new JavaScript
features, tracked properties allow Ember to reduce its API surface area while
producing code that is both more intuitive and less error-prone.</p>
<p>This simple example shows a <code>Person</code> class with three tracked properties:</p>
<pre><code class="language-js">export default class Person {
  @tracked firstName = 'Chad';
  @tracked lastName = 'Hietala';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<h3><a class="header" href="#a-note-on-decorator-support" id="a-note-on-decorator-support">A Note on Decorator Support</a></h3>
<p>This RFC proposes a decorator version of tracked properties, and uses this
decorator version in most examples, on the assumption that the [Decorators RFC]
(https://github.com/emberjs/rfcs/pull/408) will be accepted and implemented
before this RFC. If the Decorators RFC is <em>not</em> accepted, or cannot be
implemented due to other criteria not being met (such as decorators remaining at
stage 2), then only the classic class syntax for tracked properties will be
implemented.</p>
<h2><a class="header" href="#terminology" id="terminology">Terminology</a></h2>
<p>Because of the occasional overlap in terminology when discussing similar
features, this document uses the following language consistently:</p>
<ul>
<li>A <strong>getter</strong> is an ES5 JavaScript feature that executes a function to
determine the value of a property. The function is executed every time the
property is accessed.</li>
<li>A <strong>computed property</strong> is a property on an Ember object whose value is lazily
produced by executing a function. That value is nearly always cached until one
of computed property's dependencies changes.</li>
<li>A <strong>tracked property</strong> refers to any class field that has been instrumented
with <code>@tracked</code>. Unlike computed properties, tracked properties are <em>never</em>
getters or setters.</li>
<li>The <strong>classic programming model</strong> refers to the traditional Ember programming
model. It includes <em>classic classes</em>, <em>computed properties</em>, <em>event
listeners</em>, <em>observers</em>, <em>property notifications</em>, and <em>classic components</em>,
and more generally refers to features that will not be central to Ember
Octane. Concepts like <em>routes</em>, <em>controllers</em>, and <em>services</em> belong to both
the Octane programming model and the classic programming model.</li>
<li><strong>Native classes</strong> are classes defined using the Javascript <code>class</code> keyword.</li>
<li><strong>Classic classes</strong> are classes defined by subclassing from <code>EmberObject</code>
using the static <code>extend</code> method.</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Tracked properties are designed to be simpler to learn, simpler to write, and
simpler to maintain than today's computed properties. In addition to clearer
code, tracked properties eliminate the most common sources of bugs and mental
model confusion in computed properties today, and reduce memory overhead by not
caching by default.</p>
<h3><a class="header" href="#leverage-existing-javascript-knowledge" id="leverage-existing-javascript-knowledge">Leverage Existing JavaScript Knowledge</a></h3>
<p>Ember's computed properties provide functionality that overlaps with native
JavaScript getters and setters. Because native getters don't provide Ember with
the information it needs to track changes, it's not possible to use them
reliably in templates or in other computed properties.</p>
<p>New learners have to &quot;unlearn&quot; native getters, replacing them with Ember's
computed property system. Unfortunately, this knowledge is not portable to other
applications that don't use Ember that developers may work on in the future, and
while this problem may be lessened by adopting native classes and decorators, it
still requires users learn Ember's notification system and its quirks.</p>
<p>Tracked properties are as thin a layer as possible on top of native JavaScript.
Tracked properties look like normal properties because they <em>are</em> normal
properties.</p>
<p>Because there is no special syntax for retrieving a tracked property, any
JavaScript syntax that feels like it should work does work:</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<p>Similarly, syntax for changing properties works just as well:</p>
<pre><code class="language-js">// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<p>This compares favorably with APIs from other libraries, which becomes more
verbose than necessary when JavaScript syntax isn't available:</p>
<pre><code class="language-js">this.setState({
  age: this.state.age + 1,
});
</code></pre>
<pre><code class="language-js">this.setState({
  lastName: this.state.lastName + &quot;Katz&quot;;
})
</code></pre>
<h3><a class="header" href="#avoiding-dependency-hell" id="avoiding-dependency-hell">Avoiding Dependency Hell</a></h3>
<p>Currently, Ember requires developers to manually enumerate a computed property's
dependent keys: the list of <em>other</em> properties that <em>this</em> computed property
depends on. Whenever one of the listed properties changes, the computed
property's cache is cleared and any listeners are notified that the computed
property has changed.</p>
<p>In this example, <code>'firstName'</code> and <code>'lastName'</code> are the dependent keys of the
<code>fullName</code> computed property:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});
</code></pre>
<p>While this system typically works well, it comes with its share of drawbacks.</p>
<p>First, it's extra work to have to type every property twice: once as a string as
a dependent key, and again as a property lookup inside the function. While
explicit APIs can often lead to clearer code, this verbosity has the potential
to complicate the implementation without improving developer intent at all.
People understand intuitively that they are typing out dependent keys to help
<em>Ember</em>, not other programmers.</p>
<p>It's also not clear what syntax goes inside the dependent key string. In this
simple example it's a property name, but nested dependencies become a property
path, like <code>'person.firstName'</code>. (Good luck writing a computed property that
depends on a property with a period in the name.)</p>
<p>You might form the mental model that a JavaScript expression goes inside the
string—until you encounter the <code>{firstName,lastName}</code> expansion syntax or the
magic <code>@each</code> syntax for array dependencies.</p>
<p>The truth is that dependent key strings are made up of an unintuitive,
unfamiliar microsyntax that you just have to memorize if you want to use Ember
well.</p>
<p>Lastly, it's easy for dependent keys to fall out of sync with the
implementation, leading to difficult-to-detect, difficult-to-troubleshoot bugs.</p>
<p>For example, imagine a new member on our team is assigned a bug where a user's
middle name is not appearing in their profile. Our intrepid developer finds the
problem, and updates <code>fullName</code> to include the middle name:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }),
});
</code></pre>
<p>They test their change and it seems to work. Unfortunately, they've just
introduced a subtle bug. If the user's <code>middleName</code> were to change, <code>fullName</code>
wouldn't update! Maybe this will get caught in a code review, given how simple
the computed property is, but noticing missing dependencies is a challenge even
for experienced Ember developers when the computed property gets more
complicated.</p>
<p>Tracked properties have a feature called <em>autotrack</em>, where dependencies are
automatically detected as they are used. This means that as long as all
properties that are dependencies are marked as tracked, they will automatically
be detected:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Note that getters and setters do <em>not</em> need to be marked as tracked, only the
properties that they access need to. This also allows us to opt out of tracking
entirely, like if we know for instance that a given property is constant and
will never change. In general, the idea is that <em>mutable</em>, <em>watchable</em>
properties should be marked as tracked, and <em>immutable</em> or <em>unwatched</em>
properties should not be.</p>
<h3><a class="header" href="#reducing-memory-consumption" id="reducing-memory-consumption">Reducing Memory Consumption</a></h3>
<p>By default, computed properties cache their values. This is great when a
computed property has to perform expensive work to produce its value, and that
value gets used over and over again.</p>
<p>But checking, populating, and invalidating this cache comes with its own
overhead. Modern JavaScript VMs can produce highly optimized code, and in many
cases the overhead of caching is greater than the cost of simply recomputing the
value.</p>
<p>Worse, cached computed property values cannot be freed by the garbage collector
until the entire object is freed. Many computed properties are accessed only
once, but because they cache by default, they take up valuable space on the heap
for no benefit.</p>
<p>For example, imagine this component that checks whether the <code>files</code> property is
supported in input elements:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { computed } from '@ember/object';

export default Component.extend({
  inputElement: computed(function() {
    return document.createElement('input');
  }),

  supportsFiles: computed('inputElement', function() {
    return 'files' in this.inputElement;
  }),

  didInsertElement() {
    if (this.supportsFiles) {
      // do something
    } else {
      // do something else
    }
  },
});
</code></pre>
<p>This component would create and retain an <code>HTMLInputElement</code> DOM node for the
lifetime of the component, even though all we really want to cache is the
Boolean value of whether the browser supports the <code>files</code> attribute.</p>
<p>Particularly on inexpensive mobile devices, where RAM is limited and often slow, we should
be more conservative about our memory consumption. Tracked properties switch
from an opt-out caching model to opt-in, allowing developers to err on the side
of reduced memory usage, but easily enabling caching (a.k.a. memoization) if a
property shows up as a bottleneck during profiling.</p>
<h2><a class="header" href="#prior-art" id="prior-art">Prior Art</a></h2>
<p>Tracked properties were first implemented in <a href="https://glimmerjs.com/">Glimmer.js</a>,
and were recently polyfilled with clever usage of <code>notifyPropertyChange</code> by
the <a href="https://github.com/rwjblue/sparkles-component/">sparkles-components</a> addon.
These initial implementations inform the design in this RFC, but differ from it
in some key ways. For instance, both Sparkles's and early versions of Glimmer's
<code>@tracked</code> did not have an autotracking stack, and instead relied on explicit
dependency keys. After benchmarking showed that autotracking was a viable
strategy, the API for <code>@tracked</code> was updated to what is proposed here.</p>
<h2><a class="header" href="#detailed-design" id="detailed-design">Detailed Design</a></h2>
<p>This RFC proposes adding the <code>tracked</code> decorator function, used to mark class
fields as tracked:</p>
<pre><code class="language-ts">const tracked: PropertyDecorator;
</code></pre>
<p>This new function will be exported from <code>@glimmer/tracking</code>. Revisiting our
example from earlier, <code>@tracked</code> can be used on native class fields and
getters/setters:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<h3><a class="header" href="#getting-tracked-properties" id="getting-tracked-properties">Getting Tracked Properties</a></h3>
<p>Tracked properties can be accessed using standard Javascript syntax. From the
user's point of view, there is nothing special about them. This should continue
to work in the future, even if new methods are added for accessing properties,
because tracked properties use native getters under the hood.</p>
<pre><code class="language-js">let person = new Person();

// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<h3><a class="header" href="#setting-tracked-properties" id="setting-tracked-properties">Setting Tracked Properties</a></h3>
<p>Tracked properties can be set using standard Javascript syntax. They use native
setters under the hood, meaning that there is no need for using a setter method
like <code>set</code>.</p>
<pre><code class="language-js">let person = new Person();

// Simple assignment
person.firstName = 'Jen';
// Addition assignment (+=)
person.lastName += 'Weber';
// Increment operator
person.age++;
</code></pre>
<h3><a class="header" href="#autotracking" id="autotracking">Autotracking</a></h3>
<p>Tracked properties do not need to specify their dependencies. Under the hood,
this works by utilizing an <em>autotrack stack</em>. This stack is a bit of global
state which tracked properties can access. As tracked properties are accessed,
they push themselves onto the stack, and once they have finished running, the
stack contains the full list of all the tracked properties that were accessed
while it was running.</p>
<p>In our first example, with the <code>Person</code> class, we can see this in action:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>When we create a new instance of <code>Person</code>, the tracking system has no knowledge
of the connection between <code>fullName</code>, <code>firstName</code>, and <code>lastName</code>. Now, let's
say we go to render this person's name in a component's template:</p>
<pre><code class="language-hbs">{{this.person.fullName}}
</code></pre>
<p>When Glimmer accesses the <code>fullName</code> property on person, it creates an
<em>autotrack stack frame</em>. As we computed <code>fullName</code>, any values that are
decorated with <code>@tracked</code> push themselves into this stack frame. Because getters
and setters are pure functions, they will ultimately end up accessing some
tracked properties - in this case, the <code>fullName</code> getter accesses the
<code>firstName</code> and <code>lastName</code> properties, and they push themselves onto the stack
frame.</p>
<p>In this way, Glimmer will know about <em>all</em> properties that were accessed when
calculating any bound value in templates.</p>
<blockquote>
<p><strong>NOTE:</strong> This does <em>not</em> invalidate a cache like in computed properties.
Internally, Glimmer checks to see if a value has updated <em>before calling the
getter</em>. If it hasn't, then Glimmer does not rerender the related section of
the DOM. This is effectively an automatic <code>shouldComponentUpdate</code> (at least
the most common usage) from React.</p>
</blockquote>
<h3><a class="header" href="#manual-invalidation" id="manual-invalidation">Manual Invalidation</a></h3>
<p>In user code, the idea that all mutable properties should be marked as tracked
and that all other properties are effectively immutable works well in isolation.
However, there are cases where users will want to work with code they do <em>not</em>
control, such as external library code.</p>
<p>Consider the following example. We have a <code>simple-timer</code> library that we've
imported from NPM, and we're trying to wrap it with a <code>TimerComponent</code> that
uses it to keep track of how much time has passed:</p>
<pre><code class="language-js">// simple-timer/index.js
export default class Timer {
  seconds = 0;
  minutes = 0;
  hours = 0;

  listeners = [];

  constructor() {
    setInterval(() =&gt; {
      this.seconds++;
      this.minutes = Math.floor(this.seconds / 60);
      this.hours = Math.floor(this.minutes / 60);
      this.notifyTick();
    }, 1000);
  }

  notifyTick() {
    for (let listener of this.listeners) {
      listener(this.seconds);
    }
  }

  onTick(listener) {
    this.listeners.push(listener);
  }
}
</code></pre>
<pre><code class="language-js">import Timer from 'simple-timer';
import Component, { tracked } from '@glimmer/tracking';

export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<p>Even though we've marked the <code>timer</code> property as tracked, the <code>timer.seconds</code>
property is untracked, and <em>it</em> is the field that is updated. We can solve this
problem by using the timer library's <code>onTick</code> event handler to re-set the field,
invalidating it:</p>
<pre><code class="language-js">export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  constructor() {
    this.timer.onTick(() =&gt; {
      // invalidate the timer field.
      this.timer = this.timer;
    });
  }

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<h3><a class="header" href="#interop-with-the-classic-programming-model" id="interop-with-the-classic-programming-model">Interop with the Classic Programming Model</a></h3>
<p>Tracked properties represent a paradigm shift. They are a completely new system,
fully independent of the classic programming model and based on modern
Javascript features and design, and they will be the <em>default</em> change tracking
system in Ember Octane.</p>
<p>However, existing apps, libraries, and addons will be using the classic
programming model for some time, and experience tells us that these sort of
transitions to new features take a while to settle in the community. To ease
this process and enable gradual adoption, tracked properties will be able to
interoperate with the most commonly used features of the classic model:</p>
<ul>
<li>Classic classes</li>
<li>Computed properties</li>
<li><code>get</code>/<code>set</code> and property notifications</li>
<li>Observers</li>
</ul>
<h4><a class="header" href="#classic-classes" id="classic-classes">Classic Classes</a></h4>
<p>The <code>tracked</code> decorator function will be usable in classic classes, similar to
<code>computed</code>:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';

const Person = EmberObject.extend({
  firstName: tracked({ value: 'Tom' }),
  lastName: tracked({ value: 'Dale' }),

  fullName: tracked({
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
  }),
});
</code></pre>
<p>This form will <em>not</em> be allowed on native classes, and will hard error if it is
attempted. Additionally, default values will be defined on the <em>prototype</em> to
maintain consistency with the classic object model.</p>
<p>This will allow existing libraries to transition incrementally, and add tracked
support minimally where necessary. This also brings the <em>benefits</em> of tracked
to classic classes, including the ability to drop usage of <code>set</code>:</p>
<pre><code class="language-js">// before
let person = Person.create();
person.set('firstName', 'Stefan');
person.set('lastName', 'Penner');

// after
let person = Person.create();
person.firstName = 'Stefan';
person.lastName = 'Penner';
</code></pre>
<p>Ember's <code>set</code> function is nowhere to be seen!</p>
<h4><a class="header" href="#computed-properties" id="computed-properties">Computed Properties</a></h4>
<p>Computed properties will interoperate with tracked properties in both
directions:</p>
<ul>
<li>
<p>Accessing a computed property from a tracked property will add the computed
property to its list of depedencies. Whenever the computed property is
invalidated (i.e. because it or one of its dependencies is updated), the
tracked property will be invalidated as well.</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { set } from '@ember/object';
import { alias } from '@ember/object/computed';

class Person {
  @tracked firstName;
  @tracked lastName;

  @alias('title') prefix;

  get fullName() {
    return `${this.prefix} ${this.firstName} ${this.lastName}`;
  }
}

let person = new Person();

person.firstName = 'Tom';
person.lastName = 'Dale';

set(person, 'title', 'Mr.');

person.fullName; // 'Mr. Tom Dale'
</code></pre>
</li>
<li>
<p>Accessing a tracked property from a computed property will <em>also</em>
automatically add the tracked property to the list of its dependencies. In
this way, users will be able to gradually add tracked properties and
simultaneously reap the benefits of not having to use <code>set</code> with computeds,
and not having to specify dependent keys.</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  firstName;
  lastName;

  @tracked middleName;

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }
}

let person = new Person();

set(person, 'firstName', 'Tom');
set(person, 'lastName', 'Dale');

person.middleName = 'Tomster';

person.fullName; // 'Tom Tomster Dale'
</code></pre>
</li>
</ul>
<p>It will still be required to use <code>set</code> when updating computed properties and
their dependencies. In the future, this restriction could possibly be relaxed.</p>
<h4><a class="header" href="#get-and-set" id="get-and-set"><code>get</code> and <code>set</code></a></h4>
<p>It is common in the classic model to set and consume plain object properties
which are not computed properties, or in any other way special. Ember's <code>get</code>
and <code>set</code> functions historically allowed this by giving us the ability to
intercept all property changes and watch for mutations.</p>
<p>This presents a problem for tracked properties, particularly because of the
recent change in Ember to enable native Javascript getters to replace <code>get</code>.
This change means that we have no way to intercept <code>get</code>, and consequently no
way for tracked properties to know whether or not a plain property will later
be updated with <code>set</code>.</p>
<p>To demonstrate this case, consider the following service and component:</p>
<pre><code class="language-js">const Config = Service.extend({
  polling: {
    shouldPoll: false,
    pollInterval: -1,
  },

  init() {
    this._super(...arguments);

    fetch('config/api/url')
      .then(r =&gt; r.json())
      .then(polling =&gt; set(this, 'polling', polling));
  },
});
</code></pre>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let { shouldPoll, pollInterval } = this.config.polling;

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<pre><code class="language-hbs">{{this.pollInterval}}
</code></pre>
<p>Let's walk through the flow here:</p>
<ol>
<li>The <code>SomeComponent</code> component is rendered for the first time, instantiating
the <code>Config</code> service (assuming this the first time it has ever been
accessed). The service's init hook kicks off an async request to get the
configuration from a remote URl.</li>
<li>The <code>pollInterval</code> property first accesses the service injection when
rendered, which is a computed property. The property is detected and added to
the tracked stack.</li>
<li>We then access the plain, undecorated <code>polling</code> object. Because it is
is not tracked and not a computed property, tracked does not know that it
could update in the future.</li>
<li>Sometime later, the async request returns with the configuration object. We
set it on the service, but because our tracked getter did not know this
property would update, it does not invalidate.</li>
</ol>
<p>In order to prevent this from happening, user's will have to use <code>get</code> when
accessing any values which may be set with <code>set</code>, and are not computed
properties.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let shouldPoll = get(this, 'config.polling.shouldPoll');
    let pollInterval = get(this, 'config.polling.pollInterval');

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<p>The reverse, however, is not true - computed properties will be able to add
tracked properties, and listen to dependencies explicitly. In some cases, this
may be preferable, though undecorated getters should be the conventional
standard with the long term goal of removing all explicit dependencies and
computed decorations.</p>
<h4><a class="header" href="#observers" id="observers">Observers</a></h4>
<p>While Ember's observer system has been minimized in recent years, it is still
supported in Ember 3 and used occasionally throughout the ecosystem. Observers
use a fundamentally different system for tracking changes than tracked
properties, but this does not mean that it is impossible for the two systems to
interoperate, and it theory it shouldn't require much effort to maintain such
interoperation or regress performance in any meaningful way.</p>
<p>As such, tracked properties will be made to interoperate with observers so that
whenever a tracked property is set using <em>any</em> valid syntax, observers watching
that key will be fired:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { addObserver } from '@ember/object/observers';

class Person {
  constructor() {
    addObserver('firstName', () =&gt; {
      console.log('firstName changed!');
    });
  }

  @tracked firstName;
}
</code></pre>
<p>If in the implementation of this RFC it becomes apparent that there <em>are</em> major
caveats to supporting interop with observers, a followup RFC will be made to
address those caveats and make a decision on whether or not to support observers
with those additional constraints.</p>
<h3><a class="header" href="#does-this-mean-i-still-have-to-use-get-and-set" id="does-this-mean-i-still-have-to-use-get-and-set">Does this mean I still have to use <code>get</code> and <code>set</code>?</a></h3>
<p>Yes. As mentioned above, interoperating with legacy code will require using
<code>get</code> and <code>set</code> to be fully safe. However, even in greenfield applications which
do not need to interoperate with legacy addons or code, there will still be use
cases which are <em>not</em> covered by tracked properties. These use cases are roughly
the same as those that come with native <a href="https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md#motivation">ES Getters</a>:</p>
<ol>
<li>Objects that implement <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li><a href="https://emberjs.com/api/ember/release/classes/ObjectProxy">Ember proxies</a>,
which use <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li>In general, cases where change tracking should be <em>dynamic</em>, where the keys
that are being tracked are <em>not</em> known in advance and cannot be declared
using decorators.</li>
</ol>
<p><code>get</code> and <code>set</code> will continue to work (as defined in this RFC) and will be
necessary in many applications for the forseeable future. How long exactly is
an <a href="#unresolved-questions">open question addressed below in the unresolved questions section</a>.</p>
<h2><a class="header" href="#how-we-teach-this" id="how-we-teach-this">How we teach this</a></h2>
<p>There are three different aspects of tracked properties which need to be
considered for the learning story:</p>
<ol>
<li><strong>General usage.</strong> Which properties should I mark as tracked? How do I
consume them? How do I trigger changes?</li>
<li><strong>Interop with classic systems.</strong> How do I safely consume tracked properties
from classic classes and computeds? How do I safely consume classic APIs from
tracked properties?</li>
<li><strong>Interop with non-Ember systems.</strong> How do I tell my app that something has
changed in MobX objects, RxJS objects, Redux, etc.</li>
</ol>
<h3><a class="header" href="#general-usage" id="general-usage">General Usage</a></h3>
<p>The mental model with tracked properties is that anything <em>mutable</em> that is
public should be tracked. If a value will ever change, and it will or could be
watched externally, it should have the <code>@tracked</code> decorator attached to it.</p>
<p>After that, usage should be &quot;Just Javascript&quot;. You can safely access values
using any syntax you like, including desctructuring, and you can update values
using standard assignments.</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];

// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<h4><a class="header" href="#triggering-updates-on-complex-objects" id="triggering-updates-on-complex-objects">Triggering Updates on Complex Objects</a></h4>
<p>There may be cases where users want to update values in complex, untracked
objects such as arrays or POJOs. <code>@tracked</code> will only be usable with class
syntax at first, and while it may make sense to formalize these objects into
tracked classes in some cases, this will not always be the case.</p>
<p>To do this, users can re-set a tracked value directly after its inner values
have been updated.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @tracked items = [];

  @action
  pushItem(item) {
    let { items } = this;

    items.push(item);

    this.items = items;
  }
}
</code></pre>
<p>This may seem a bit strange at first, but it allows users to mentally scope
off a tree of objects. They manipulate internals as they see fit, and the only
operation they need to do to update state is set the nearest tracked property.</p>
<h3><a class="header" href="#interop-with-classic-systems" id="interop-with-classic-systems">Interop with Classic Systems</a></h3>
<p>There are two cases that we need to consider when teaching interoperability:</p>
<ol>
<li>Accessing non-tracked properties and computeds from an autotrack context</li>
<li>Accessing tracked properties from a computed context</li>
</ol>
<p>In the first case, the general rule of thumb is to use <code>get</code> if you want to be
100% safe. In cases where you are certain that the values you are accessing are
tracked, computeds, or immutable, you can safely use standard access syntax.</p>
<p>In the second case, no additional changes need to be made when using tracked
properties. They can be accessed as normal, and will be automatically added to
the computed's dependencies. There is no need to use <code>get</code>, and you can use
standard assignments when updating them.</p>
<h3><a class="header" href="#interop-with-non-ember-systems" id="interop-with-non-ember-systems">Interop with Non-Ember Systems</a></h3>
<p>The strategy for trickier updates on complex objects by retriggering their
setters should cover most integration use cases. We should add a guide which
specifically demonstrates their usage by wrapping a common, simple external
library such as <code>moment.js</code>. This will demonstrate its usage concretely, and
establish best practices.</p>
<h2><a class="header" href="#drawbacks" id="drawbacks">Drawbacks</a></h2>
<p>Like any technical design, tracked properties must make tradeoffs to balance
performance, simplicity, and usability. Tracked properties make a different set
of tradeoffs than today's computed properties.</p>
<p>This means tracked properties come with edge cases or &quot;gotchas&quot; that don't exist
in computed properties. When evaluating the following drawbacks, please consider
the two features in their totality, including computed property gotchas you have
learned to work around.</p>
<p>In particular, please try to compensate for <a href="https://en.wikipedia.org/wiki/Familiarity_heuristic">familiarity</a> and
<a href="https://en.wikipedia.org/wiki/Loss_aversion">loss aversion</a> biases. Before you form a strong opinion, <a href="https://signalvnoise.com/posts/3124-give-it-five-minutes">give
it five minutes</a>.</p>
<h3><a class="header" href="#tracked-properties--promises" id="tracked-properties--promises">Tracked Properties &amp; Promises</a></h3>
<p>Dependency autotracking requires that tracked getters access their dependencies
synchronously. Any access that happens asynchronously will not be detected as a
dependency.</p>
<p>This is most commonly encountered when trying to return a <code>Promise</code> from a
tracked getter. Here's an example that would &quot;work&quot; but would never update if
<code>firstName</code> or <code>lastName</code> change:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullNameAsync() {
    return this.reloadUser().then(() =&gt; {
      return `${this.firstName} ${this.lastName}`;
    });
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }

  setFirstName(firstName) {
    // This should cause `fullNameAsync` to update, but doesn't, because
    // firstName was not detected as a dependency.
    this.firstName = firstName;
  }
}
</code></pre>
<p>One way you could address this is to ensure that any dependencies are consumed
synchronously:</p>
<pre><code class="language-js">get fullNameAsync() {
  // Consume firstName and lastName so they are detected as dependencies.
  let { firstName, lastName } = this;

  return this.reloadUser().then(() =&gt; {
    // Fetch firstName and lastName again now that they may have been updated
    let { firstName, lastName } = this;
    return `${firstName} ${lastName}`;
  });
}
</code></pre>
<p>However, <strong>modeling async behavior as tracked properties is an incoherent
approach and should be discouraged</strong>. Tracked properties are intended to hold
simple state, or to derive state from data that is available synchronously.</p>
<p>But asynchrony is a fact of life in web applications, so how should we deal with
async data fetching?</p>
<p><strong>In keeping with Data Down, Actions Up, async behavior should be modeled as
methods that set tracked properties once the behavior is complete.</strong></p>
<p>Async behavior should be explicit, not a side-effect of property access. Today's
computed properties that rely on caching to only perform async behavior when a
dependency changes are effectively reintroducing observers into the programming
model via a side channel.</p>
<p>A better approach is to call a method to perform the async data fetching, then
set one or more tracked properties once the data has loaded. We can refactor the
above example back to a synchronous <code>fullName</code> tracked property:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
</code></pre>
<p>Now, <code>reloadUser()</code> must be called explicitly, rather than being run implicitly
as a side-effect of consuming <code>fullName</code>.</p>
<h3><a class="header" href="#accidental-untracked-properties" id="accidental-untracked-properties">Accidental Untracked Properties</a></h3>
<p>One of the design principles of tracked properties is that they are only
required for state that <em>changes over time</em>. Because tracked properties imply
some overhead over an untracked property (however small), we only want to pay
that cost for properties that actually change.</p>
<p>However, an obvious failure mode is that some property <em>does</em> change over time,
but the user simply forgets to annotate that property as <code>@tracked</code>. This will
cause frustrating-to-diagnose bugs where the DOM doesn't update in response to
property changes.</p>
<p>Fortunately, we have a strategy for mitigating some of this frustration. It
involves the way most tracked properties will be consumed: via a component
template. In development mode, we can detect when an untracked property is used
in a template and install a setter that causes an exception to be thrown if it
is ever mutated. (This is similar to today's &quot;mandatory setter&quot; that causes an
exception to be thrown if a watched property is set without going through
<code>set()</code>.)</p>
<p>Unfortunately this strategy cannot be applied to values accessed by tracked
getters. The only way we could detect such access would be with native
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>, but proxies are more focussed on security over flexibility
and recent discussion shows that <a href="https://github.com/tc39/proposal-class-fields/issues/106">they may break entirely when used with
private fields</a>. As
such, it would not be ideal for us to use them in this way.</p>
<h2><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h2>
<h3><a class="header" href="#ship-tracked-properties-in-user-land" id="ship-tracked-properties-in-user-land">Ship tracked properties in user-land</a></h3>
<p>Instead of shipping <code>@tracked</code> today, we can focus on formalizing the primitives
which it uses under the hood in Glimmer VM (References and Validators) and make
these publicly consumable. This way, users will be able to implement tracked in
an addon and experiment with it before it becomes a core part of Ember.</p>
<p>This approach is similar to the approach taken with component managers in the
past year, which unblocked experimentation with <code>SparklesComponent</code>s as a way to
validate the design of <code>GlimmerComponent</code>s, and unlocked the ability for power
users to create their own component APIs. However, the reference and validator
system is a much more core part of the Glimmer VM, and it could take much longer
to figure out the best and safest way to do this without exposing too much of
the internals. It would certainly prevent <code>@tracked</code> from shipping with Ember
Octane.</p>
<h3><a class="header" href="#keep-the-current-system" id="keep-the-current-system">Keep the current system</a></h3>
<p>We could keep the current computed property based system, and refactor it
internally to use references only and not rely on chains or the old property
notification system. This would be difficult, since CPs are very intertwined
with property events as are their dependencies. It would also mean we wouldn't
get the DX benefits of cleaner syntax, and the performance benefits of opt-in
change tracking and caching.</p>
<h3><a class="header" href="#we-could-keep-set" id="we-could-keep-set">We could keep <code>set</code></a></h3>
<p>Tracked properties were designed around wanting to use native setters to update
state. If we remove that constraint and keep <code>set</code>, it opens up some
possibilities. There is precedent for this in other frameworks, such as React's
<code>setState</code>.</p>
<p>However, keeping <code>set</code> likely wouldn't be able to restrict the requirement for
<code>@tracked</code> being applied to all mutable properties for the same reason <code>get</code>
must be used in interop - there's no way for a tracked property to know that a
plain, undecorated property could update in the future.</p>
<h3><a class="header" href="#allow-explicit-dependencies" id="allow-explicit-dependencies">Allow explicit dependencies</a></h3>
<p>We could allow <code>@tracked</code> to receive explicit dependencies instead of forcing
<code>get</code> usage for interop. This would be very complex, if even possible, and is
ultimately not functionality <code>@tracked</code> should have in the long run, so it would
not make sense to add it now.</p>
<h3><a class="header" href="#we-could-wait-on-private-fields-and-proxy-developments" id="we-could-wait-on-private-fields-and-proxy-developments">We could wait on private fields and Proxy developments</a></h3>
<p>Native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a> represent a lot of possibilities for automatic change
tracking. Other frameworks such as Vue and Aurelia are looking into using
recursive proxy structures to wrap objects and intercept access, which would
allow them to track changes without <em>any</em> decoration. We also considered using
recursive proxies in earlier drafts of this proposal, even though they aren't
part of our support matrix we believed they could be used during development to
assert when users attempted to update untracked properties which had been
consumed from tracked getters.</p>
<p>However, as mention above, TC39 has made it clear that this was <a href="https://github.com/tc39/proposal-class-fields/issues/106">not an intended
use for Proxy</a>, and
they will be <em>breaking</em> this functionality with the inclusion of private fields.
They have also expressed that <a href="https://github.com/tc39/proposal-class-fields/issues/162#issuecomment-441101578">they would like to solve this
use-case</a>
(observing object state changes in general) separately, and <a href="https://github.com/littledan/proposal-proxy-transparent">a strawman proposal
was made</a> (though it
has not advanced and does not seem like it will). We could wait to see what the
future looks like here, and see if we can provide a more ergonomic tracked
properties RFC in the future.</p>
<h2><a class="header" href="#unresolved-questions" id="unresolved-questions">Unresolved questions</a></h2>
<h3><a class="header" href="#when-can-i-stop-using-get-and-set" id="when-can-i-stop-using-get-and-set">When can I stop using <code>get</code> and <code>set</code>?</a></h3>
<p>This is the biggest open question in this RFC, and with the direction that
tracked properties set. How do we get rid of <code>get</code> and <code>set</code> for good, if that
is the direction we want to go in?</p>
<p>The full answer to that question is out of scope for tracked properties, but it
would likely require at least two additional steps:</p>
<ol>
<li>
<p>The underlying system for tracking changes, including the ability to create
tags for fields and the ability to add to the current autotracking stack,
will need to be made public for advanced users who need dynamic change
tracking.</p>
</li>
<li>
<p>First class support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">native proxies</a> within Ember.
<code>unknownProperty</code> and <code>setUnknownProperty</code> have no other analag in native
Javascript, and without support for native proxies there will likely be use
cases that cannot be supported in any other way.</p>
<p>As mentioned above, native proxies <em>will</em> (potentially) have more limitations
than Ember proxies, but these limitations will most likely be possible to
work around for advanced users who need this functionality in the first
place. In other words, while they probably don't make sense as a basis for
<em>all</em> change tracking in Ember, they will probably be invaluable for specific
use cases such as <a href="https://www.npmjs.com/package/ember-m3">Ember M3</a> which
require very dynamic change tracking.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="0408-decorators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="0415-render-element-modifiers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="0408-decorators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="0415-render-element-modifiers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
