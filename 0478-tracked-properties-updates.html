<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0478-tracked-properties-updates - </title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0001-transform-attribute-meta-parameter.html">0001-transform-attribute-meta-parameter</a></li><li><a href="0003-block-params.html">0003-block-params</a></li><li><a href="0003-cli-ember-doctor.html">0003-cli-ember-doctor</a></li><li><a href="0010-engines.html">0010-engines</a></li><li><a href="0011-improved-cp-syntax.html">0011-improved-cp-syntax</a></li><li><a href="0012-help-json-output.html">0012-help-json-output</a></li><li><a href="0015-the-road-to-ember-2-0.html">0015-the-road-to-ember-2-0</a></li><li><a href="0020-sri-default.html">0020-sri-default</a></li><li><a href="0023-command-line-completion.html">0023-command-line-completion</a></li><li><a href="0024-bound-attributes.html">0024-bound-attributes</a></li><li><a href="0028-app-import-output-file.html">0028-app-import-output-file</a></li><li><a href="0029-addon-black-and-whitelist-for-apps.html">0029-addon-black-and-whitelist-for-apps</a></li><li><a href="0045-internet-explorer.html">0045-internet-explorer</a></li><li><a href="0046-cli-improved-release-process.html">0046-cli-improved-release-process</a></li><li><a href="0046-registry-reform.html">0046-registry-reform</a></li><li><a href="0050-cli-production-code-stripping.html">0050-cli-production-code-stripping</a></li><li><a href="0050-improved-actions.html">0050-improved-actions</a></li><li><a href="0053-helpers.html">0053-helpers</a></li><li><a href="0055-anonymous-amd.html">0055-anonymous-amd</a></li><li><a href="0056-improved-release-cycle.html">0056-improved-release-cycle</a></li><li><a href="0057-ember-data-reference-unification.html">0057-ember-data-reference-unification</a></li><li><a href="0058-helper-listing.html">0058-helper-listing</a></li><li><a href="0061-ember-data-background-fetch.html">0061-ember-data-background-fetch</a></li><li><a href="0064-contextual-component-lookup.html">0064-contextual-component-lookup</a></li><li><a href="0065-deprecation-warning-handlers.html">0065-deprecation-warning-handlers</a></li><li><a href="0080-serve-file-api.html">0080-serve-file-api</a></li><li><a href="0086-firefox-in-ci.html">0086-firefox-in-ci</a></li><li><a href="0090-addon-tree-caching.html">0090-addon-tree-caching</a></li><li><a href="0091-cli-addon-instrumentation-experimental-hooks.html">0091-cli-addon-instrumentation-experimental-hooks</a></li><li><a href="0091-weakmap.html">0091-weakmap</a></li><li><a href="0092-blueprint-remove-old-files.html">0092-blueprint-remove-old-files</a></li><li><a href="0095-cli-standardise-targets.html">0095-cli-standardise-targets</a></li><li><a href="0095-router-service.html">0095-router-service</a></li><li><a href="0096-enable-yarn-usage.html">0096-enable-yarn-usage</a></li><li><a href="0101-ember-data-friendly-errors.html">0101-ember-data-friendly-errors</a></li><li><a href="0105-addons-optionalDependencies.html">0105-addons-optionalDependencies</a></li><li><a href="0108-add-custom-transform.html">0108-add-custom-transform</a></li><li><a href="0110-packaging.html">0110-packaging</a></li><li><a href="0114-add-template-lint-addon.html">0114-add-template-lint-addon</a></li><li><a href="0116-qunit-dom.html">0116-qunit-dom</a></li><li><a href="0120-cli-guides.html">0120-cli-guides</a></li><li><a href="0120-route-serializers.html">0120-route-serializers</a></li><li><a href="0121-remove-ember-cli-eslint.html">0121-remove-ember-cli-eslint</a></li><li><a href="0136-contains-to-includes.html">0136-contains-to-includes</a></li><li><a href="0139-isHtmlSafe.html">0139-isHtmlSafe</a></li><li><a href="0143-module-unification.html">0143-module-unification</a></li><li><a href="0150-factory-for.html">0150-factory-for</a></li><li><a href="0176-javascript-module-api.html">0176-javascript-module-api</a></li><li><a href="0178-deprecate-ember-k.html">0178-deprecate-ember-k</a></li><li><a href="0181-deprecate-ember-data-initializers.html">0181-deprecate-ember-data-initializers</a></li><li><a href="0186-track-unique-history-location-state.html">0186-track-unique-history-location-state</a></li><li><a href="0191-deprecate-component-lifecycle-hook-args.html">0191-deprecate-component-lifecycle-hook-args</a></li><li><a href="0194-deprecate-custom-event-manager.html">0194-deprecate-custom-event-manager</a></li><li><a href="0213-custom-components.html">0213-custom-components</a></li><li><a href="0225-ember-engines-mount-params.html">0225-ember-engines-mount-params</a></li><li><a href="0226-named-blocks.html">0226-named-blocks</a></li><li><a href="0229-deprecate-testing-restricted-resolver.html">0229-deprecate-testing-restricted-resolver</a></li><li><a href="0232-simplify-qunit-testing-api.html">0232-simplify-qunit-testing-api</a></li><li><a href="0236-deprecation-ember-string.html">0236-deprecation-ember-string</a></li><li><a href="0237-deprecation-ember-map.html">0237-deprecation-ember-map</a></li><li><a href="0240-es-classes.html">0240-es-classes</a></li><li><a href="0252-browser-support-changes.html">0252-browser-support-changes</a></li><li><a href="0268-acceptance-testing-refactor.html">0268-acceptance-testing-refactor</a></li><li><a href="0272-deprecation-native-function-prototype-extensions.html">0272-deprecation-native-function-prototype-extensions</a></li><li><a href="0276-named-args.html">0276-named-args</a></li><li><a href="0278-template-only-components.html">0278-template-only-components</a></li><li><a href="0280-remove-application-wrapper.html">0280-remove-application-wrapper</a></li><li><a href="0281-es5-getters.html">0281-es5-getters</a></li><li><a href="0286-block-let-template-helper.html">0286-block-let-template-helper</a></li><li><a href="0287-promote-in-element-to-public-api.html">0287-promote-in-element-to-public-api</a></li><li><a href="0293-record-data.html">0293-record-data</a></li><li><a href="0294-optional-jquery.html">0294-optional-jquery</a></li><li><a href="0297-deprecate-ember-logger.html">0297-deprecate-ember-logger</a></li><li><a href="0300-rfc-process-update.html">0300-rfc-process-update</a></li><li><a href="0308-deprecate-property-lookup-fallback.html">0308-deprecate-property-lookup-fallback</a></li><li><a href="0311-angle-bracket-invocation.html">0311-angle-bracket-invocation</a></li><li><a href="0318-array-helper.html">0318-array-helper</a></li><li><a href="0322-deprecate-copy-copyable.html">0322-deprecate-copy-copyable</a></li><li><a href="0324-deprecate-component-isvisible.html">0324-deprecate-component-isvisible</a></li><li><a href="0326-ember-data-filter-deprecation.html">0326-ember-data-filter-deprecation</a></li><li><a href="0329-deprecated-ember-evented-in-ember-data.html">0329-deprecated-ember-evented-in-ember-data</a></li><li><a href="0331-deprecate-globals-resolver.html">0331-deprecate-globals-resolver</a></li><li><a href="0332-ember-data-record-links-and-meta.html">0332-ember-data-record-links-and-meta</a></li><li><a href="0335-deprecate-send-action.html">0335-deprecate-send-action</a></li><li><a href="0337-native-class-constructor-update.html">0337-native-class-constructor-update</a></li><li><a href="0340-deprecate-ember-merge.html">0340-deprecate-ember-merge</a></li><li><a href="0345-discord.html">0345-discord</a></li><li><a href="0364-roadmap-2018.html">0364-roadmap-2018</a></li><li><a href="0369-deprecate-computed-clobberability.html">0369-deprecate-computed-clobberability</a></li><li><a href="0370-deprecate-computed-volatile.html">0370-deprecate-computed-volatile</a></li><li><a href="0372-ember-data-model-factory-for.html">0372-ember-data-model-factory-for</a></li><li><a href="0373-Element-Modifier-Managers.html">0373-Element-Modifier-Managers</a></li><li><a href="0375-deprecate-computed-property-modifier.html">0375-deprecate-computed-property-modifier</a></li><li><a href="0386-remove-jquery.html">0386-remove-jquery</a></li><li><a href="0389-dynamic-tag-names.html">0389-dynamic-tag-names</a></li><li><a href="0391-router-helpers.html">0391-router-helpers</a></li><li><a href="0392-deprecate-component-manager-string-lookup.html">0392-deprecate-component-manager-string-lookup</a></li><li><a href="0395-ember-data-packages.html">0395-ember-data-packages</a></li><li><a href="0398-RouteInfo-Metadata.html">0398-RouteInfo-Metadata</a></li><li><a href="0403-ember-data-identifiers.html">0403-ember-data-identifiers</a></li><li><a href="0408-decorators.html">0408-decorators</a></li><li><a href="0410-tracked-properties.html">0410-tracked-properties</a></li><li><a href="0415-render-element-modifiers.html">0415-render-element-modifiers</a></li><li><a href="0416-glimmer-components.html">0416-glimmer-components</a></li><li><a href="0418-deprecate-route-render-methods.html">0418-deprecate-route-render-methods</a></li><li><a href="0421-deprecate-application-controller-props.html">0421-deprecate-application-controller-props</a></li><li><a href="0425-website-redesign.html">0425-website-redesign</a></li><li><a href="0431-guides-restructure.html">0431-guides-restructure</a></li><li><a href="0432-contextual-helpers.html">0432-contextual-helpers</a></li><li><a href="0435-modifier-splattributes.html">0435-modifier-splattributes</a></li><li><a href="0440-decorator-support.html">0440-decorator-support</a></li><li><a href="0445-deprecate-with.html">0445-deprecate-with</a></li><li><a href="0446-contribution-guides.html">0446-contribution-guides</a></li><li><a href="0449-deprecate-partials.html">0449-deprecate-partials</a></li><li><a href="0451-injection-parameter-normalization.html">0451-injection-parameter-normalization</a></li><li><a href="0452-ember-data-medium-term-plan.html">0452-ember-data-medium-term-plan</a></li><li><a href="0457-nested-lookups.html">0457-nested-lookups</a></li><li><a href="0459-angle-bracket-built-in-components.html">0459-angle-bracket-built-in-components</a></li><li><a href="0460-yieldable-named-blocks.html">0460-yieldable-named-blocks</a></li><li><a href="0461-ember-data-singleton-record-data.html">0461-ember-data-singleton-record-data</a></li><li><a href="0463-record-data-state.html">0463-record-data-state</a></li><li><a href="0465-record-data-errors.html">0465-record-data-errors</a></li><li><a href="0466-request-state-service.html">0466-request-state-service</a></li><li><a href="0468-classic-decorator.html">0468-classic-decorator</a></li><li><a href="0470-fn-helper.html">0470-fn-helper</a></li><li><a href="0471-on-modifier.html">0471-on-modifier</a></li><li><a href="0478-tracked-properties-updates.html" class="active">0478-tracked-properties-updates</a></li><li><a href="0481-component-templates-co-location.html">0481-component-templates-co-location</a></li><li><a href="0486-deprecate-mouseenter.html">0486-deprecate-mouseenter</a></li><li><a href="0487-custom-model-classes.html">0487-custom-model-classes</a></li><li><a href="0491-deprecate-disconnect-outlet.html">0491-deprecate-disconnect-outlet</a></li><li><a href="0494-async-observers.html">0494-async-observers</a></li><li><a href="0521-find-by-identifier.html">0521-find-by-identifier</a></li><li><a href="0522-default-serializers-and-adapters.html">0522-default-serializers-and-adapters</a></li><li><a href="0523-model-argument-for-route-templates.html">0523-model-argument-for-route-templates</a></li><li><a href="0554-deprecate-getwithdefault.html">0554-deprecate-getwithdefault</a></li><li><a href="0558-edition-detection.html">0558-edition-detection</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2019-04-12</li>
<li>Relevant Team(s): Ember.js, Learning</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/478</li>
<li>Tracking: https://github.com/emberjs/rfc-tracking/issues/45</li>
</ul>
<h1><a class="header" href="#tracked-properties-updates" id="tracked-properties-updates">Tracked Properties Updates</a></h1>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>During the Ember Octane preview period we encountered some issues with the
current design for Tracked Properties that was proposed and accepted in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0410-tracked-properties.md">RFC 410</a>.
The primary issues were specifically around interop between tracked properties,
computed properties, and autotracking, with a few extra issues and
inconsistencies surrounding these. This RFC seeks to fix these issues and
provide a new interop path.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>During the preview for Octane, we've encountered a few issues with tracked
properties:</p>
<ol>
<li>Computed property autotracking interop was too aggresive, and resulted in
breaking changes in existing applications.</li>
<li>When users need to use <code>get()</code> and <code>set()</code> is still fairly confusing, and we
don't have enough warnings to help guide users down the happy path.</li>
<li>Users were confused by the fact that <code>set()</code> was still required when updating
computed properties, especially CP macros like <code>DS.attr()</code>.</li>
</ol>
<h3><a class="header" href="#autotracking-interop" id="autotracking-interop">Autotracking Interop</a></h3>
<p>The core of the autotracking issue was that autotracking <em>inside</em> computed
properties resulted in more values being consumed and watched than before,
fundamentally changing the dynamic of the CP. For instance, consider this code
example:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  init(...args) {
    this._super(...args);

    let fullName = `${this.get('firstName')} ${this.get('lastName')}`;

    this.set('fullName', fullName);
  },
});

const Profile = EmberObject.create({
  person: computed('firstName', 'lastName', function() {
    return Person.create({
      firstName: this.get('firstName'),
      lastName: this.get('lastName'),
    });
  }),
});
</code></pre>
<p>The <code>Profile#person</code> computed would currently only invalidate if
<code>Profile#firstName</code> or <code>Profile#lastName</code> was updated, and it would be possible
to update the person like so:</p>
<pre><code class="language-js">// without autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // true
</code></pre>
<p>However, because <code>get</code> now autotracks, the fact that the <code>Person</code> class uses
<code>this.get()</code> in its own constructor causes <code>Profile#person.firstName</code> to
autotrack. When we go to update the object later on, it invalidates the
underlying computed property.</p>
<pre><code class="language-js">// with autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // false
</code></pre>
<p>It's arguable that computed properties that are relying on these caching
semantics are problematic in general. After all, it's strange to setup state
like this <em>during</em> construction, usually you would use a CP instead, and if CPs
<em>are</em> trying to use a value, it generally means that value <em>should</em> be a
dependency. However, based on our experiences with attempting to upgrade
existing applications to enable autotracking, we believe it likely would result
in enough breakage that it would be a breaking change.</p>
<h3><a class="header" href="#when-to-use-get-and-set" id="when-to-use-get-and-set">When to Use <code>get</code> and <code>set</code></a></h3>
<p>While the original tracked properties RFC laid the groundwork for getting rid of
<code>get</code> and <code>set</code> in the browser, there are still cases where users need to use
it. Specifically, users must use <code>get</code> and <code>set</code> when:</p>
<ul>
<li>Getting and setting values on POJOs</li>
<li>Using Ember Proxies</li>
<li>Setting Computed Properties</li>
</ul>
<p>Ember proxies already throw errors if users don't use <code>get</code> and <code>set</code>, so users
can generally get the feedback they need for them, and setting computed
properties is addressed in the next section. For POJOs, however, the feedback
can be lacking. Users could access a POJO from a tracked context like so:</p>
<pre><code class="language-js">class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }
}
</code></pre>
<p>And later on, try to update <code>featureFlags.someValueEnabled</code>, and be confused
when it doesn't work and they don't have any actionable feedback:</p>
<pre><code class="language-js">class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }

  @action
  updateFlag() {
    this.featureFlags.someValueEnabled = true;
  }
}
</code></pre>
<p>Adding an assertion to values that are accessed like this which requires <code>set</code>
will help to prevent confusion from occuring.</p>
<h3><a class="header" href="#computed-property-setters" id="computed-property-setters">Computed Property Setters</a></h3>
<p>As we move toward removing <code>get</code> and <code>set</code> entirely, computed properties stick
out somewhat as a sore thumb. They generally look and feel like standard getters
and setters with some caching, but while modern Ember users can use native
getters to <em>get</em> the computed, they must use <code>set()</code> to update them. This is
particularly annoying when dealing with macros, like aliases and Ember Data
attributes such as <code>DS.attr</code>.</p>
<p>Installing a native setter for computed properties will smooth over these
inconistencies, and give us a clear learning boundary for <code>get</code> and <code>set</code> - you
only need to use them for plain, undecorated properties on POJOs, and for Ember
proxies.</p>
<h2><a class="header" href="#detailed-design" id="detailed-design">Detailed design</a></h2>
<h3><a class="header" href="#autotracking-interop-1" id="autotracking-interop-1">Autotracking Interop</a></h3>
<p>Not all of the interop in the original RFC was problematic, and as such, the
following parts will remain the same:</p>
<ul>
<li><code>get</code> - will still autotrack any value that is accessed</li>
<li><code>set</code>/<code>notifyPropertyChange</code> - will still invalidate any value that was
accessed with <code>get</code></li>
<li>Computed properties - will still autotrack <em>if accessed in an autotracking
context</em>.</li>
</ul>
<p>What will change is that computed properties will no longer autotrack as they
are being evaluated. Instead, they will follow the same rules as they do
currently, listing explicit dependencies and only invalidating when one of those
dependencies changes. Any autotracking that may have occured during the
computation of the computed will instead no-op, making the computed a <em>black
box</em>.</p>
<p>Since computed properties no longer autotrack, they will need a different
interop story for tracked properties and autotracking. Autotracking is a very
general tool - as we saw in the motivation, it's possible to track through
<em>function calls</em>, something that wasn't possible before.</p>
<p>However, we don't need to enable interop with <em>all</em> of autotracking. All we
really need is the ability to depend on the autotracking equivalents of what
computed properties already are capable of depending on, so that users can
convert existing code to autotracking incrementally. Computed properties can
already depend on:</p>
<ul>
<li>Properties</li>
<li>Other Computed Properties</li>
</ul>
<p>The equivalents to these in autotracking are:</p>
<ul>
<li>Tracked Properties</li>
<li>Native Getters</li>
</ul>
<h4><a class="header" href="#depending-on-tracked-properties" id="depending-on-tracked-properties">Depending on Tracked Properties</a></h4>
<p>Tracked properties are already instrumented under the hood. They have a native
setter that calls <code>notifyPropertyChange</code>, and this will automatically invalidate
any computeds that specify the property as a dependency. There is no need to do
any further work.</p>
<h4><a class="header" href="#depending-on-native-getters" id="depending-on-native-getters">Depending on Native Getters</a></h4>
<p>Native getters are just that - native. They don't have any special autotracking
behavior, which was part of the benefits of tracked properties. However, this
means there is nothing to notify computed properties of changes.</p>
<p>To solve this problem, we propose the <code>@dependentKeyCompat</code> decorator. This decorator
would instrument a native getter with its own autotracking frame, which would
allow it to track any events in its evaluation. It would coalesce these into its
own tag, which computed properties (and observers) would be able to depend on:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

const Profile = EmberObject.extend({
  // provided on create
  person: null,

  username: alias('person.fullName'),
});
</code></pre>
<p><code>@dependentKeyCompat</code> would be imported from <code>@ember/object/compat</code>, since it is used
specifically in Ember apps for interop with Ember object model abstractions.
Like other Ember decorators, it would be usable in both classic and native
classes. When used in classic classes, it will be able to define its underlying
getter and setter using the same API as computed properties. However, it will
throw an error if it is used to define more than one getter/setter - dependentKeyCompat
macros should be avoided and discouraged.</p>
<p>Observers and computed properties will throw an error if they attempt to watch
a getter which is not marked as dependentKeyCompat.</p>
<h4><a class="header" href="#debugging-assertions" id="debugging-assertions">Debugging Assertions</a></h4>
<p>Consuming a value using <code>get()</code> inside of a tracked context will both autotrack
the value, and in <em>development</em> builds install the mandatory setter assertion.
This assertion already exists and is currently installed on values that are
watched by computeds, observers, and templates, but not for values accessed
using <code>get()</code>. Extending it to these values should not be too difficult.</p>
<h3><a class="header" href="#computed-property-setters-1" id="computed-property-setters-1">Computed Property Setters</a></h3>
<p>Computed properties will no longer install the mandatory setter assertion like
they have for much of Ember's existence. Instead, they will install a native
setter that proxies to the one defined for the computed property. This will
allow users to use native setters instead of <code>set()</code>.</p>
<h2><a class="header" href="#how-we-teach-this" id="how-we-teach-this">How we teach this</a></h2>
<p>There are two major points of consideration here:</p>
<ul>
<li>How do we teach classic/autotrack interop and <code>@dependentKeyCompat</code></li>
<li>How do we teach <code>get</code>/<code>set</code> and when they are necessary to use</li>
</ul>
<h3><a class="header" href="#classicautotrack-interop" id="classicautotrack-interop">Classic/Autotrack Interop</a></h3>
<p>Many of the points from the original tracked property RFC remain valid, but we
will have to update the way that we teach computed properties. In some ways the
overall mental model is simplified - computed properties will only update
whenever a dependent property is updated, as they always have. The following
table describes what types of values can be depended on, and how they can
trigger updates:</p>
<table><thead><tr><th>Type</th><th>Updates By</th></tr></thead><tbody>
<tr><td>Plain, undecorator property</td><td><code>set()</code></td></tr>
<tr><td>Tracked property</td><td>Native setter</td></tr>
<tr><td>Computed property</td><td><code>set()</code>, or upstream invalidations</td></tr>
<tr><td>Dependency compatible getters</td><td>Tracked value changes</td></tr>
</tbody></table>
<p>We should cover each of these in some detail in the main guides.</p>
<h4><a class="header" href="#dependentkeycompat-api-docs" id="dependentkeycompat-api-docs"><code>@dependentKeyCompat</code> API Docs</a></h4>
<p><code>@dependentKeyCompat</code> is decorator that can be used on <em>native getters</em> that use tracked
properties. It exposes the getter to Ember's classic computed property and
observer systems, so they can watch it for changes. It can be used in both
native and classic classes.</p>
<p>Native Example:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import { computed, set } from '@ember/object';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Profile {
  constructor(person) {
    set(this, 'person', person);
  }

  @computed('person.fullName')
  get helloMessage() {
    return `Hello, ${this.person.fullName}!`;
  }
}
</code></pre>
<p>Classic Example:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import EmberObject, { computed, observer, set } from '@ember/object';

const Person = EmberObject.extend({
  firstName: tracked(),
  lastName: tracked(),

  fullName: dependentKeyCompat(function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});

const Profile = EmberObject.extend({
  person: null,

  helloMessage: computed('person.fullName', function() {
    return `Hello, ${this.person.fullName}!`;
  }),

  onNameUpdated: observer('person.fullName', function() {
    console.log('person name updated!');
  }),
});
</code></pre>
<p><code>dependentKeyCompat()</code> can receive a getter function or an object containing <code>get</code>/<code>set</code>
methods when used in classic classes, like computed properties.</p>
<p>In general, only properties which you <em>expect</em> to be watched by older, untracked
clases should be marked as dependency compatible. The decorator is meant as an interop layer
for parts of Ember's older classic APIs, and should not be applied to every
possible getter/setter in classes. The number of dependency compatible getters should be
<em>minimized</em> wherever possible. New application code should not need to use
<code>@dependentKeyCompat</code>, since it is only for interoperation with older code.</p>
<h3><a class="header" href="#computed-properties" id="computed-properties">Computed Properties</a></h3>
<p>Computed properties are a pre-Octane concept in Ember. They serve the same
purpose as tracked properties and native getters, allowing users to respond to
changes, derive state, and ultimately update the DOM. They also have built-in
caching to prevent having to perform expensive calculations more than once.</p>
<p>While computed properties are no longer the recommended default, it's likely
that you may encounter them in code that hasn't been updated to tracked
properties just yet, either in existing applications or in the wider Ember
ecosystem, so this guide exists both to describe how they work and can be used,
and how they interoperate with tracked properties.</p>
<h4><a class="header" href="#computed-property-usage" id="computed-property-usage">Computed Property Usage</a></h4>
<p>You can create a computed property by using the <code>@computed</code> decorator to
decorate standard computed property getters and setters:</p>
<pre><code class="language-javascript">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
</code></pre>
<p>This computed property works just like a normal getter/setter, with two key
differences:</p>
<ol>
<li>
<p>It will cache its value by default, and it will only update that value if its
<em>dependencies</em>, in this case the <code>firstName</code> and <code>lastName</code> properties,
change.</p>
<pre><code class="language-javascript">class Counter {
  _count = 0;

  @computed
  get count() {
    console.log('counted!');
    return this._count;
  }
}

let counter = new Counter();

counter.count; // logs 'counted!'
counter.count; // logs nothing, the values was cached and hasn't updated
</code></pre>
</li>
<li>
<p>It will notify other &quot;watchers&quot;, such as other computed properties and
templates, if any of its dependencies has updated and it needs to be
recalculated.</p>
</li>
</ol>
<h5><a class="header" href="#specifying-dependencies" id="specifying-dependencies">Specifying Dependencies</a></h5>
<p>So far we've seen computed properties with dependencies on properties that are
<em>local</em> to the object, but you can specify a few other types of dependencies:</p>
<ul>
<li>
<p><strong>Chain dependencies.</strong> If you need to specify a dependency on an <em>object</em>,
you can use dot notation to do so:</p>
<pre><code class="language-js">class Profile {
  constructor(user) {
    set(this, 'user', user);
  }

  @computed('user.firstName', 'user.lastName')
  get userName() {
    return `${this.user.firstName} ${this.user.lastName}`;
  }
}
</code></pre>
<p>When doing this for more than one value on the object, you can also use a
special truncated syntax as shorthand:</p>
<pre><code class="language-js">class Profile {
  constructor(user) {
    set(this, 'user', user);
  }

  @computed('user.{firstName,lastName}')
  get userName() {
    return `${this.user.firstName} ${this.user.lastName}`;
  }
}
</code></pre>
<p>Note that no spaces are allowed in this truncated syntax, Ember will assert if
you place any inside of it.</p>
</li>
<li>
<p><strong>Array dependencies.</strong> It's possible to depend on an array, and the items in
the array, by watching the <code>[]</code> property on the array:</p>
<pre><code class="language-js">class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}
</code></pre>
<p>You can also depend directly on a <em>property</em> of each item in the array using
<code>@each</code> syntax:</p>
<pre><code class="language-js">class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.@each.name')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}
</code></pre>
<p>However, you cannot <em>chain</em> on these properties, as it is a performance
pitfall. You can only do 1 level of <code>@each</code> watching.</p>
</li>
</ul>
<h5><a class="header" href="#defining-setters" id="defining-setters">Defining Setters</a></h5>
<p>If you define a setter for your computed property, it'll work just like a normal
setter:</p>
<pre><code class="language-javascript">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }
}

let hero = new Person('Tony', 'Stark');

hero.fullName; // 'Tony Stark'

hero.fullName = 'Hope Pym';
hero.firstName; // 'Hope'
</code></pre>
<p>It's worth noting that we do <em>not</em> need to use <code>set</code> to update the computed
property. It wraps the native setter transparently, so there is no need for the
set function. The properties it <em>depends</em> on, however, <em>do</em> need to be updated
with <code>set</code>, since they are not marked as <code>@tracked</code> and we don't have another
way of knowing they were updated. We will dive into this a bit more below.</p>
<p>The setter will also immediately call the getter for the computed in order to
recalculate the cached value. You can also return the value, as an optimization:</p>
<pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  }
}
</code></pre>
<h5><a class="header" href="#computed-property-macros" id="computed-property-macros">Computed Property Macros</a></h5>
<p>It's possible to define <em>macros</em> using computed properties. This works because
the <code>@computed</code> decorator can receive getter and setter functions, and be
applied to a normal class field instead of a getter/setter:</p>
<pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  // Just a getter function
  @computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
  fullName;

  // With setter and getter
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  })
  fullNameWithSetter;
}
</code></pre>
<p>You can then extract this decorator to create a new decorator definition:</p>
<pre><code class="language-js">const fullNameMacro = computed('firstName', 'lastName', {
  get() {
    return `${this.firstName} ${this.lastName}`;
  },

  set(key, value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  },
});

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName;
}
</code></pre>
<p>And we can abstract this further to create a function that generates the
decorator dynamically, which allows us to reuse the macro:</p>
<pre><code class="language-js">function fullNameMacro(firstNameKey, lastNameKey) {
  return computed(firstNameKey, lastNameKey, {
    get() {
      return `${this[firstNameKey]} ${this[lastNameKey]}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, firstNameKey, firstName);
      set(this, lastNameKey, lastName);

      return value;
    },
  });
}

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName('firstName', 'lastName');
  @otherFullNameMacro fullName('first', 'last');
}
</code></pre>
<p>When you provide a getter and setter like this to <code>@computed</code>, the getter and
setter receive the <code>key</code> of the property they are decorating as the first value,
and the setter receives the actual value second. The setter also <strong>must</strong> return
the value to be cached - the getter will not be rerun if it does not, and the
value will be <code>undefined</code>.</p>
<h5><a class="header" href="#computed-properties-in-classic-classes" id="computed-properties-in-classic-classes">Computed Properties in Classic Classes</a></h5>
<p>Computed properties can be used in classic class syntax as well. This works by
passing the getter and setter to the <code>computed()</code> decorator just like we would
for a macro:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  }),
});
</code></pre>
<h4><a class="header" href="#computed-property-dependency-types" id="computed-property-dependency-types">Computed Property Dependency Types</a></h4>
<p>You may have noticed that in the previous section, our computed properties were
depending on normal, undecorated properties. This is possible in classic Ember
if we always update those properties using Ember's <code>set</code> method, which is why
all of the examples use it. Computed properties can depend on other types of
values as well though. Altogether, the types of values are:</p>
<ul>
<li>Plain, undecorated object properties</li>
<li><code>@tracked</code> properties</li>
<li><code>@computed</code> properties</li>
<li><code>@dependentKeyCompat</code> getters</li>
<li>Arrays</li>
</ul>
<p>We'll talk about each of these individually, and discuss how they are watched
and updated.</p>
<h5><a class="header" href="#plain-properties" id="plain-properties">Plain Properties</a></h5>
<p>In all the examples above, we demonstrated computed properties that depended on
plain object properties which hadn't been otherwise decorated. This was the
default in classic Ember, before tracked properties were introduced, and it
still works today - however, to trigger updates on a plain property dependency,
you <em>must</em> use <code>set</code>:</p>
<pre><code class="language-js">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
ironMan.firstName = 'Anthony'; // This will throw an error
set(ironMan, 'firstName', 'Anthony'); // This will work, and update `fullName`
</code></pre>
<p>In general Ember will try to throw an error if you should use <code>set</code> to update a
value, but you didn't.</p>
<h5><a class="header" href="#tracked-properties" id="tracked-properties">Tracked Properties</a></h5>
<p>Computed properties can also depend directly on tracked properties, and tracked
properties do <em>not</em> need to be updated with <code>set</code>. Updating them with normal
JavaScript update syntax will invalidate them:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
ironMan.firstName = 'Anthony'; // Now this will work, because 'firstName' is tracked!
</code></pre>
<h5><a class="header" href="#computed-properties-1" id="computed-properties-1">Computed Properties</a></h5>
<p>Computed properties can depend on other computed properties. If you depend on a
computed property, it will only trigger updates if <em>its</em> dependencies update, or
if you set it directly:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}

let hero = new Person('Tony', 'Stark');

hero.legalName; // 'Tony Stark'

hero.fullName = 'Hope Pym'; // Invalidates `legalName`
hero.legalName; // 'Hope Pym'

hero.firstName = 'Hank'; // Invalidates `fullName` _and_ `legalName`
hero.fullName; // 'Hank Pym'
hero.legalName; // 'Hank Pym'
</code></pre>
<h5><a class="header" href="#dependency-compatible-getters" id="dependency-compatible-getters">Dependency Compatible Getters</a></h5>
<p>In modern, fully tracked classes, computed properties aren't recommended
anymore. However, if you are working in a legacy codebase and converting to
tracked properties and native getters, there may be a point in time where you
try to convert a computed property that is being depended on by <em>other</em> computed
properties. Native getters normally <em>cannot</em> be depended on, and this will
trigger an error in development mode.</p>
<p>However, this doesn't mean that you need to convert an entire tree of computed
properties every time you try to update a class! Instead, you can mark native
getters that need to be depended on by computed properties with the <code>@dependentKeyCompat</code>
decorator:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}
</code></pre>
<p>This decorator exposes the getter to computed properties, but otherwise leaves
it untouched - it'll operate just like a normal native getter with tracked
properties. When you have removed all computed properties that are depending on the
getter, you can remove the <code>@dependentKeyCompat</code> decorator.</p>
<p>In general, you should try to remove <code>@dependentKeyCompat</code> decorators as you convert your
app. Making getters compatible with the explicit dependency system means that more computeds can be written to watch
those getters, and the situation can get <em>worse</em> instead of better over time. If
you need to write a service or class that needs to interop with modern and
classic code for some time, try to <em>minimize</em> the number of <code>@dependentKeyCompat</code> getters
to just the ones that are the &quot;public API&quot; of the class - the values that are
expected to be depended on from the outside by other classes.</p>
<h5><a class="header" href="#arrays" id="arrays">Arrays</a></h5>
<p>As we mentioned above, computed properties can specify dependencies on arrays.
They can watch for changes in the items of the array by watching the <code>[]</code> key of
the array, and they can watch for changes on properties of the items using the
<code>@each</code> syntax.</p>
<p>In order to be properly notified of changes to an array, you either use KVO
compliant methods of Ember arrays such as <code>pushObject</code> or <code>popObject</code>, or <code>set</code>
the entire array:</p>
<pre><code class="language-js">import { computed, set } from '@ember/object';
import { A as emberA } from '@ember/array';

class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}

let joey = new Person(
  emberA([
    { name: 'Phoebe' },
    { name: 'Monica' },
    { name: 'Chandler' },
    { name: 'Ross' },
  ])
);

// Using pushObject will cause `friendNames` to update
joey.friends.pushObject({ name: 'Rachel' });

// Alternatively, we can update the whole array:
set(joey, 'friends', [...joey.friends, { name: 'Rachel' }]);
</code></pre>
<p>If the property is tracked, then <code>set</code> is not necessary, and the field can be
updated directly as you would with normal tracked properties:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracking friends;

  constructor(friends = []) {
    this.friends = friends;
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}

let joey = new Person([
  { name: 'Phoebe' },
  { name: 'Monica' },
  { name: 'Chandler' },
  { name: 'Ross' },
]);

joey.friends = [...joey.friends, { name: 'Rachel' }];
</code></pre>
<h4><a class="header" href="#computed-properties-and-tracking" id="computed-properties-and-tracking">Computed Properties and Tracking</a></h4>
<p>Computed properties will autotrack when they are accessed from templates or
through other getters, like tracked properties:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  // legalName will update whenever `fullName` updates
  get legalName() {
    return this.fullName;
  }
}
</code></pre>
<h3><a class="header" href="#when-to-use-get-and-set-1" id="when-to-use-get-and-set-1">When to Use <code>get</code> and <code>set</code></a></h3>
<p>Ember's classic change tracking system used two methods to ensure that all data
was accessed properly and updated correctly: <code>get</code> and <code>set</code>.</p>
<pre><code class="language-js">import { get, set } from '@ember/object';

let person = {};

set(person, 'firstName', 'Amy');
set(person, 'lastName', 'Lam');

get(person, 'firstName'); // 'Amy'
get(person, 'lastName'); // 'Lam'
</code></pre>
<p>In classic Ember, all property access had to go through these two methods. Over
time, these rules have become less strict, and now they have been minimized to
just a few cases. In general, in a modern Ember app, you shouldn't need to use
them all that much. As long as you are marking your properties as <code>@tracked</code>,
autotracking should automatically figure out what needs to change, and when.</p>
<p>However, there still are two cases where you <em>will</em> need to use them:</p>
<ul>
<li>When accessing and updating plain, undecorated properties on objects</li>
<li>When using Ember's <code>ObjectProxy</code> class, or a class that implements the
<code>unknownProperty</code> function (which allows objects to intercept <code>get</code> calls)</li>
</ul>
<p>Additionally, you will have to continue using <em>accessor</em> functions for arrays if
you want arrays to update as expected. These functions are covered in more
detail in the guide on arrays (LINK TO ARRAY GUIDES HERE).</p>
<p>Importantly, you do <em>not</em> have to use <code>get</code> or <code>set</code> when reading or updating
computed properties, as was noted in the computed property section.</p>
<h4><a class="header" href="#plain-properties-1" id="plain-properties-1">Plain Properties</a></h4>
<p>In general, if a value in your application could update, and that update should
trigger rerenders, then you should mark that value as <code>@tracked</code>. This
oftentimes may mean taking a POJO and turning it into a class, but this is
usually better because it forces us to <em>rationalize</em> the object - think about
what its API is, what values it has, what data it represents, and define that in
a single place.</p>
<p>However, there are times when data is <em>too</em> dynamic. As noted below, proxies are
often used for this type of data, but usually they're overkill. Most of the
time, all we want is a POJO.</p>
<p>In those cases, you can still use <code>get</code> and <code>set</code> to read and update state from
POJOs within your getters, and these will track automatically and trigger
updates.</p>
<pre><code class="language-js">class Profile {
  person = {
    firstName: 'Chris',
    lastName: 'Thoburn',
  };

  get profileName() {
    return `${get(this.person, 'firstName')} ${get(this.person, 'lastName')}`;
  }
}

let profile = new Profile();

// render the page...

set(profile.person, 'firstName', 'Christopher'); // triggers an update
</code></pre>
<p>This is also useful for interoperating with older Ember code which has not yet
been updated to tracked properties. If you're unsure, you can use <code>get</code> and
<code>set</code> to be safe.</p>
<h4><a class="header" href="#objectproxy" id="objectproxy"><code>ObjectProxy</code></a></h4>
<p>Ember has and continues to support an implementation of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>,
which is a type of object that can <em>wrap around</em> other objects and <em>intercept</em>
all of your gets and sets to them. Native JavaScript proxies allow you to do
this without any special methods or syntax, but unfortunately they are not
available in IE11. Since many Ember users must still support IE11, Ember's
<code>ObjectProxy</code> class allows us to accomplish something similar.</p>
<p>The use cases for proxies are generally cases where some data is very dynamic,
and its not possible to know ahead of time how to create a class that is
decorated. For instance, <a href="https://github.com/hjdivad/ember-m3">ember-m3</a> is an
addon that allows Ember Data to work with dynamically generated models instead
of models defined using <code>@attr</code>, <code>@hasMany</code>, and <code>@belongsTo</code>. This cuts back on
code shipped to the browser, but it means that the models have to <em>dynamically</em>
watch and update values. A proxy allows all accesses and updates to be
intercepted, so M3 can do what it needs to do without predefined classes.</p>
<p>Most <code>ObjectProxy</code> classes have their own <code>get</code> and <code>set</code> method on them, like
<code>EmberObject</code> classes. This means you can use them directly on the class
instance:</p>
<pre><code class="language-js">proxy.get('firstName');
proxy.set('firstName', 'Amy');
</code></pre>
<p>If you're unsure whether or not a given object will be a proxy or not, you can
still use Ember's <code>get</code> and <code>set</code> functions:</p>
<pre><code class="language-js">get(maybeProxy, 'firstName');
set(maybeProxy, 'firstName', 'Amy');
</code></pre>
<h2><a class="header" href="#drawbacks" id="drawbacks">Drawbacks</a></h2>
<ul>
<li>The interop story here may a bit confusing for users at first. <code>@dependentKeyCompat</code>
should only be used in some cases, and it could unclear when it should be
used. Documentation should help alleviate this, along with clear examples.</li>
<li>We're introducing a decorator that will eventually be deprecated and removed
as part of this process, which is essentially some tech debt we're taking on.
However, we know that this has a timeline for removal, and it is purely a
temporary measure for interop, so it's not a significant amount of debt to
take on in the meantime.</li>
</ul>
<h2><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h2>
<ul>
<li>We could not provide <code>@dependentKeyCompat</code> instead. This would mean there isn't really
an interop path for users who want to depend on native getters from CPs and
observers, leaving a large gap that could prevent users from updating
altogether.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="0471-on-modifier.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="0481-component-templates-co-location.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="0471-on-modifier.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="0481-component-templates-co-location.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
